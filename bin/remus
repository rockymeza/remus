#!/usr/bin/env ruby
require File.dirname(__FILE__) + '/../lib/vendor/trollop/trollop'
require File.dirname(__FILE__) + '/../lib/remus'


options = Trollop::options do
  version "Remus 0.9.2 (c) 2010 Rocky Meza, William Scales"
  banner <<-EOS
Remus is a syntax highlighter

Usage:
       remus [options] [code]
where [options] are:
EOS

  opt :filename, "A file to be colored, Remus will try to identify the language", :type => String
  opt :language, "The language of the code to be colored", :type => String
  opt :token_class, "The output format", :type => String
  opt :example, "Run with this flag to get example output, you can specify language and token_class", :default => false
end

if options[:example]
  puts( 'Remus Test Run')

  lang = options[:language] || :html
  token_class = options[:token_class] || :sh
  
  output = '--------------------- '+ Remus.classify(lang) +"\n"
  start_time = Time.new.to_f
  output << Remus.convert_from_file( 'examples/example.'+ lang.to_s, :token_class => token_class )
  end_time = Time.new.to_f
  output << 'Time: '+ (end_time - start_time).to_s
else
  if ! $stdin.tty? # if code is piped in
    code = $stdin.read unless $stdin.tty? # grab code that is piped in
    options[:language] = Remus.parse_shebang code if ! options[:language] # try to detect language
  elsif ! ARGV[0].nil?
    code = ARGV[0]
  end
  Trollop::die :language, 'No language detected, please specify a language' if ( code && ! options[:language] )

  options.delete_if { |key,value| value.nil? } # remove empties
  defaults = { :token_class => :sh } # defaults hash
  options = defaults.merge options # merge options into defaults

  if code
    
    output = Remus.convert( code, options[:language], options )
    
  elsif options[:filename]
    
    output = Remus.convert_from_file( options[:filename], options )
    
  end
end # options[:example]

if output
  ENV['LESS'] = 'FSRX'
  IO.popen("/usr/bin/less","w") { |p| p.puts output}
end
